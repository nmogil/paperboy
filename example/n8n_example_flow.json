{
  "name": "arxiv-digest",
  "nodes": [
    {
      "parameters": {
        "url": "https://arxiv.org/catchup/cs/2025-04-01",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [240, 0],
      "id": "40c3446f-7782-4765-9929-e12a31aa326d",
      "name": "Fetch Latest Articles"
    },
    {
      "parameters": {
        "jsCode": "// --- n8n Code Node Script (Improved Regex Version - No External Libs) ---\n// WARNING: This regex-based approach is fragile and highly dependent\n// on the exact HTML structure provided in the example.\n// It may break if the source arXiv HTML changes significantly.\n\nfunction parseArxivNewSubmissionsWithRegexDetailed() {\n  // --- Configuration ---\n  const BASE_URL = \"https://arxiv.org\"; // Base URL for relative links\n\n  // --- Input ---\n  let htmlString = \"\";\n  try {\n    htmlString = $input.first().json.data;\n    if (typeof htmlString !== 'string') {\n      throw new Error(\"Input data is not a string.\");\n    }\n  } catch (e) {\n    console.error(\"Error accessing input data:\", e);\n    if (typeof $throw !== 'undefined' && typeof $throw.error === 'function') {\n      $throw.error(`Could not read input data: ${e.message}`);\n    }\n    return { submissions: [], error: `Could not read input data: ${e.message}` };\n  }\n\n  const results = []; // Array to hold the parsed submission objects\n\n  if (!htmlString || htmlString.trim() === '') {\n    console.log(\"Error: Invalid or empty input HTML string.\");\n    return { submissions: [], error: \"Invalid or empty input HTML.\" };\n  }\n  console.log(`Input HTML received. Length: ${htmlString.length}`);\n\n  try {\n    const articlesDlRegex = /<dl\\s+id=['\"]articles['\"][^>]*>([\\s\\S]*?)<\\/dl>/i;\n    const articlesDlMatch = htmlString.match(articlesDlRegex);\n    if (!articlesDlMatch || !articlesDlMatch[1]) {\n      console.log(\"Error: Could not find or extract content from <dl id='articles'> section.\");\n      return { submissions: [], error: \"Could not find <dl id='articles'> section.\" };\n    }\n    const articlesHtml = articlesDlMatch[1];\n    console.log(\"Successfully extracted content within <dl id='articles'>.\");\n\n    const newSubmissionsHeadingRegex = /<h3[^>]*>\\s*New submissions[\\s\\S]*?<\\/h3>/i;\n    let headingMatch = articlesHtml.match(newSubmissionsHeadingRegex);\n    let startIndex = 0; // Default to start if heading not found\n\n    if (headingMatch && typeof headingMatch.index === 'number') {\n       startIndex = headingMatch.index + headingMatch[0].length;\n       console.log(`Found 'New submissions' heading. Start index for content: ${startIndex}`);\n    } else {\n       console.log(\"Warning: 'New submissions' heading not found. Assuming content starts from the beginning of <dl>.\");\n       // Optional: Fallback to first <dt> if needed, but starting from 0 might be safer if heading is missing\n    }\n\n\n    const contentAfterHeading = articlesHtml.substring(startIndex);\n    const nextHeadingRegex = /<h3/i;\n    const nextHeadingMatch = contentAfterHeading.match(nextHeadingRegex);\n\n    let endIndex = articlesHtml.length; // Default to end if no next heading\n    if (nextHeadingMatch && typeof nextHeadingMatch.index === 'number') {\n      endIndex = startIndex + nextHeadingMatch.index;\n      console.log(`Found next <h3> tag. Absolute end index: ${endIndex}`);\n    } else {\n      console.log(\"No subsequent <h3> found, using end of <dl> content as end index.\");\n    }\n\n    const newSubmissionsHtml = articlesHtml.substring(startIndex, endIndex);\n    if (!newSubmissionsHtml || newSubmissionsHtml.trim().length === 0) {\n      console.log(\"Warning: Extracted newSubmissionsHtml section is empty.\");\n      return { submissions: [], error: \"New submissions section appears empty.\" };\n    }\n    console.log(`Extracted newSubmissionsHtml length: ${newSubmissionsHtml.length}. Starting extraction.`);\n\n    const dtDdPairRegex = /<dt[^>]*>([\\s\\S]*?)<\\/dt>\\s*<dd[^>]*>([\\s\\S]*?)<\\/dd>/gis;\n\n    // --- Regexes for extracting specific data ---\n    // Regex to capture the main arXiv link, its href path, and the ID within the path.\n    // It specifically looks for href starting with \"/abs/\" and having title=\"Abstract\"\n    const arxivLinkRegex = /<a\\s+href=[\"'](\\/abs\\/([^\"']+))[\"'][^>]*title=[\"']Abstract[\"']/i;\n\n    const pdfLinkRegex = /<a\\s+href=[\"'](\\/pdf\\/[^\"']+)[\"'][^>]*title=[\"']Download PDF[\"']/i;\n    const htmlLinkRegex = /<a\\s+href=[\"']([^\"']+)[\"'][^>]*title=[\"']View HTML[\"']/i;\n\n    const titleRegex = /<div class=[\"']list-title mathjax[\"']>\\s*<span class=[\"']descriptor[\"']>Title:<\\/span>\\s*([\\s\\S]*?)<\\/div>/is;\n    const authorsRegex = /<div class=[\"']list-authors[\"']>([\\s\\S]*?)<\\/div>/is;\n    const authorLinkRegex = /<a\\s+href=[\"'][^\"']+[\"'][^>]*>([\\s\\S]*?)<\\/a>/gi;\n    const commentsRegex = /<div class=[\"']list-comments mathjax[\"']>\\s*<span class=[\"']descriptor[\"']>Comments:<\\/span>\\s*([\\s\\S]*?)<\\/div>/is;\n    const subjectsRegex = /<div class=[\"']list-subjects[\"']>\\s*<span class=[\"']descriptor[\"']>Subjects:<\\/span>\\s*([\\s\\S]*?)<\\/div>/is;\n    const primarySubjectRegex = /<span class=[\"']primary-subject[\"'][^>]*>([\\s\\S]*?)<\\/span>/i;\n\n    const cleanText = (htmlSnippet) => {\n      if (!htmlSnippet) return null;\n      return htmlSnippet.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n    };\n\n    let match;\n    let pairsFound = 0;\n\n    console.log(\"Starting loop to find DT/DD pairs...\");\n    while ((match = dtDdPairRegex.exec(newSubmissionsHtml)) !== null) {\n      pairsFound++;\n      const dtContent = match[1];\n      const ddContent = match[2];\n\n      let titleText = null;\n      let authorsText = null;\n      let commentsText = null;\n      let subjectsText = null;\n      let primarySubjectText = null;\n      let abstractUrl = null;\n      let htmlUrl = null;\n      let pdfUrl = null;\n      let arxivId = null;\n\n      // --- Extract from DT: ID and Abstract URL first ---\n      const arxivMatch = dtContent.match(arxivLinkRegex);\n      if (arxivMatch && arxivMatch[1] && arxivMatch[2]) {\n        const relativeAbsPath = arxivMatch[1];\n        arxivId = arxivMatch[2]; // ID extracted from the path\n        abstractUrl = `${BASE_URL}${relativeAbsPath}`; // Construct full URL\n      } else {\n         // Fallback if the specific abstract link format isn't found\n         const fallbackIdTextMatch = dtContent.match(/arXiv:([\\d.]+)/i);\n         if (fallbackIdTextMatch && fallbackIdTextMatch[1]) {\n             arxivId = fallbackIdTextMatch[1];\n             // Construct abstract URL from text ID if available\n             abstractUrl = `${BASE_URL}/abs/${arxivId}`;\n             console.log(`   Warning: Used fallback to find text ID ${arxivId} and constructed abstract URL for pair ${pairsFound}.`);\n         } else {\n             console.log(`   ERROR: Could not find arXiv ID or abstract link for pair ${pairsFound}. Skipping.`);\n             continue; // Skip this entry if no ID can be found\n         }\n      }\n\n      // Extract other URLs using the BASE_URL logic\n      const pdfMatch = dtContent.match(pdfLinkRegex);\n      if (pdfMatch && pdfMatch[1]) {\n        pdfUrl = pdfMatch[1].startsWith('/') ? `${BASE_URL}${pdfMatch[1]}` : pdfMatch[1];\n      }\n\n      const htmlMatch = dtContent.match(htmlLinkRegex);\n      if (htmlMatch && htmlMatch[1]) {\n        htmlUrl = htmlMatch[1].startsWith('/') ? `${BASE_URL}${htmlMatch[1]}` : htmlMatch[1];\n      }\n\n      // --- Extract from DD ---\n      const titleMatch = ddContent.match(titleRegex);\n      if (titleMatch && titleMatch[1]) {\n        titleText = cleanText(titleMatch[1]);\n      } else {\n        console.log(`   Warning: No title found for pair ${pairsFound} (ID: ${arxivId})`);\n        // Decide if missing title is critical; currently allows proceeding\n      }\n\n      const authorsMatch = ddContent.match(authorsRegex);\n      if (authorsMatch && authorsMatch[1]) {\n        const authorNames = [];\n        let authorLinkMatch;\n        while ((authorLinkMatch = authorLinkRegex.exec(authorsMatch[1])) !== null) {\n          authorNames.push(cleanText(authorLinkMatch[1]));\n        }\n        authorsText = authorNames.length > 0 ? authorNames.join(', ') : cleanText(authorsMatch[1]);\n      }\n\n      const commentsMatch = ddContent.match(commentsRegex);\n      if (commentsMatch && commentsMatch[1]) {\n        commentsText = cleanText(commentsMatch[1]);\n      }\n\n      const subjectsMatch = ddContent.match(subjectsRegex);\n      if (subjectsMatch && subjectsMatch[1]) {\n        const subjectsContent = subjectsMatch[1]; // Keep the raw inner HTML\n        subjectsText = cleanText(subjectsContent); // Cleaned version for the 'subjects' field\n        const primarySubjectMatch = subjectsContent.match(primarySubjectRegex);\n        if (primarySubjectMatch && primarySubjectMatch[1]) {\n          primarySubjectText = cleanText(primarySubjectMatch[1]);\n        }\n      }\n\n      // Create the submission data object (ensure critical fields like ID are present)\n      const submissionData = {\n        arxiv_id: arxivId, // Should always be populated if we didn't 'continue'\n        title: titleText, // Might be null if regex failed\n        abstract_url: abstractUrl, // Should be populated if ID was found\n        pdf_url: pdfUrl,\n        html_url: htmlUrl,\n        authors: authorsText,\n        subjects: subjectsText,\n        primary_subject: primarySubjectText,\n        comments: commentsText,\n      };\n      results.push(submissionData);\n\n      if (pairsFound <= 5) { // Log first few successful extractions\n        console.log(`   Processed Pair ${pairsFound}: ID=${arxivId}, Title=${titleText ? titleText.substring(0, 30) + '...' : 'N/A'}, AbstractURL=${abstractUrl}`);\n      }\n\n    } // End while loop\n\n    if (pairsFound === 0) {\n        console.log(\"Warning: Loop finished, but no DT/DD pairs were matched in the 'New submissions' section.\");\n    } else {\n        console.log(`Finished processing. Found ${pairsFound} DT/DD pairs. Successfully extracted ${results.length} submissions.`);\n    }\n\n  } catch (error) {\n    console.error(\"Error during HTML processing with regex:\", error);\n     if (typeof $throw !== 'undefined' && typeof $throw.error === 'function') {\n      $throw.error(`Processing error: ${error.message}`);\n    }\n    return { submissions: [], error: `Processing error: ${error.message}` };\n  }\n\n  return { submissions: results };\n}\n\n// --- n8n Code Node Execution ---\nconst parsedData = parseArxivNewSubmissionsWithRegexDetailed();\nreturn [{ json: parsedData }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 0],
      "id": "7da98214-ba80-48e8-8480-1b4c303a27e6",
      "name": "Code"
    },
    {
      "parameters": {
        "model": "deepseek/deepseek-chat-v3-0324:free",
        "options": {
          "maxTokens": 10000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [640, 180],
      "id": "c8aa22e3-ee7b-4823-a826-ccbb75b8baa0",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "0emqceKCxbxdUOSs",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"submissions\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"arxiv_id\": {\n            \"type\": \"string\"\n          },\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"abstract_url\": {\n            \"type\": \"string\"\n          },\n          \"pdf_url\": {\n            \"type\": \"string\"\n          },\n          \"html_url\": {\n            \"type\": [\"string\", \"null\"]\n          },\n          \"authors\": {\n            \"type\": \"string\"\n          },\n          \"subjects\": {\n            \"type\": \"string\"\n          },\n          \"primary_subject\": {\n            \"type\": \"string\"\n          },\n          \"comments\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [800, 180],
      "id": "403d9ea0-2da5-4fb2-9e03-8255cd48f0cf",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "fieldToSplitOut": "output.submissions",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [1020, 0],
      "id": "9bfd424c-bb45-484e-a34c-2a4af67371be",
      "name": "Split Out"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1200, 0],
      "id": "50808fa8-295e-4324-8642-cb348b14bcf0",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "model": "deepseek/deepseek-chat-v3-0324:free",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [1360, 260],
      "id": "9d5ff016-1f6e-4f89-8739-d55faf1dbe62",
      "name": "OpenRouter Chat Model1",
      "credentials": {
        "openRouterApi": {
          "id": "0emqceKCxbxdUOSs",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Read the article abstract to get a summary of that it's about.",
        "url": "={{ $json.abstract_url }}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [1580, 460],
      "id": "61144df8-6ff5-4b3b-86b4-d9030c553773",
      "name": "GET Abstract"
    },
    {
      "parameters": {
        "toolDescription": "Read HTML Article, if it's null only read the abstract.",
        "url": "={{ $json.html_url }}",
        "optimizeResponse": true,
        "responseType": "html",
        "onlyContent": true,
        "elementsToOmit": "header,footer,nav,aside,form,.header,.sidebar,.footer",
        "truncateResponse": true
      },
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [1420, 460],
      "id": "467b7cc9-4dda-404b-8e40-a34d5bda059e",
      "name": "GET Article"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [0, 0],
      "id": "5bde4955-e526-4e27-b976-e74bb7382474",
      "name": "When clicking ‘Test workflow’"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1540, -140],
      "id": "3aad8dcd-06c4-4e95-98a6-68285fe1f02b",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"arxiv_id\": { \"type\": \"string\" },\n    \"title\": { \"type\": \"string\" },\n    \"abstract_url\": { \"type\": \"string\", \"format\": \"uri\" },\n    \"pdf_url\": { \"type\": \"string\", \"format\": \"uri\" },\n    \"html_url\": { \"type\": [\"string\", \"null\"], \"format\": \"uri\" },\n    \"authors\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n    \"subjects\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n    \"primary_subject\": { \"type\": \"string\" },\n    \"comments\": { \"type\": \"string\" },\n    \"published_date\": { \"type\": \"string\", \"format\": \"date\" },\n    \"source\": { \"type\": \"string\" },\n    \"ai_summary\": { \"type\": \"string\" },\n    \"ai_key_take_aways\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n    \"personalized_summary\": { \"type\": \"string\" },\n    \"why_it_matters_to_user\": { \"type\": \"string\" },\n    \"relevance_score\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 1 },\n    \"tags\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n    \"length_minutes\": { \"type\": \"number\" }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [1760, 260],
      "id": "d018ee4b-a686-475a-82d6-ddbba7702b76",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=What are the 5 most relevant research papers for a product manager working at Twilio.com?\nArticles:\n{{ JSON.stringify($json.submissions) }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "You are a helpful assistant that recommends research papers for users to research. You should always select the 5 most relevant submissions for the user. ALWAYS output the response in JSON in the exact format below. And ONLY include articles that have an HTML page.\n\nEnsure your output/response is in the exact JSON format below:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"submissions\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"arxiv_id\": {\n            \"type\": \"string\"\n          },\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"abstract_url\": {\n            \"type\": \"string\"\n          },\n          \"pdf_url\": {\n            \"type\": \"string\"\n          },\n          \"html_url\": {\n            \"type\": [\"string\", \"null\"]\n          },\n          \"authors\": {\n            \"type\": \"string\"\n          },\n          \"subjects\": {\n            \"type\": \"string\"\n          },\n          \"primary_subject\": {\n            \"type\": \"string\"\n          },\n          \"comments\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    }\n  }\n}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [640, 0],
      "id": "a12f0a10-4488-4013-b95c-364d538094d9",
      "name": "Relevance & Ranker",
      "retryOnFail": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Users Goal: Understand how I should think about leverging AI at Twilio.com\nArticle to research\narxiv_id: {{ $json.arxiv_id }}\ntitle: {{ $json.title }}\nabstract_url: {{ $json.abstract_url }}\nhtml_url: {{ $json.html_url }}\nauthors: {{ $json.authors }}\nsubjects: {{ $json.subjects }}\ncomments: {{ $json.comments }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are a research assistant tasked with reading articles and providing key takeaways and key points that will help the user achieve their goal."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [1480, 20],
      "id": "23defa63-de73-42f1-ba83-d557e6bc6fdf",
      "name": "Researcher"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Please create a newsletter specific to my career and goals using the below information.",
        "messages": {
          "messageValues": [
            {
              "message": "You are an expert copy writer creating a personalized newsletter. Create a newsletter in markdown."
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [1760, -140],
      "id": "a7194240-54ba-44c3-a4a7-f62ea8a64476",
      "name": "Newsletter Writer"
    },
    {
      "parameters": {
        "model": "deepseek/deepseek-chat-v3-0324:free",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [1900, 40],
      "id": "3eacf302-689b-4e0f-93ea-0a96f46ad4d3",
      "name": "OpenRouter Chat Model2",
      "credentials": {
        "openRouterApi": {
          "id": "0emqceKCxbxdUOSs",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "resource": "draft",
        "subject": "NEWSLETTER READY",
        "message": "This is a test",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [2080, -160],
      "id": "0892854a-e18d-415b-9854-676c973050dd",
      "name": "Gmail",
      "webhookId": "8a13c827-da55-4283-8670-6bfb23eeffeb",
      "credentials": {
        "gmailOAuth2": {
          "id": "xpDgLyPqrnO0enHG",
          "name": "Gmail account"
        }
      }
    }
  ],
  "pinData": {
    "When clicking ‘Test workflow’": [
      {
        "json": {}
      }
    ]
  },
  "connections": {
    "Fetch Latest Articles": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Relevance & Ranker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Relevance & Ranker",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Relevance & Ranker",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Researcher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Researcher",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "GET Abstract": {
      "ai_tool": [
        [
          {
            "node": "Researcher",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "GET Article": {
      "ai_tool": [
        [
          {
            "node": "Researcher",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Test workflow’": {
      "main": [
        [
          {
            "node": "Fetch Latest Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Researcher",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Relevance & Ranker": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Researcher": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Newsletter Writer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Newsletter Writer",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Newsletter Writer": {
      "main": [
        [
          {
            "node": "Gmail",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "56f16f43-a657-49e2-a9b3-4e863713ebf4",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "0f94426859b9d23c8ab85f74122f08835cbad427a72398b752822053d359864f"
  },
  "id": "vGLLKkOh0Q9Ki5IS",
  "tags": []
}
